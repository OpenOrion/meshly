/**
 * Integration test for loading Python-generated meshes in TypeScript.
 * 
 * This test loads a TexturedMesh fixture generated by Python to verify
 * the TypeScript implementation can properly decode meshes created by
 * the Python library.
 */
import * as fs from 'fs'
import * as path from 'path'
import { beforeAll, describe, expect, it } from 'vitest'
import { Mesh } from '../mesh'
import { Packable } from '../packable'

/**
 * Interface matching the Python TexturedMesh structure
 */
interface TexturedMeshData {
    // Base mesh fields
    vertices: Float32Array
    indices?: Uint32Array
    indexSizes?: Uint32Array
    cellTypes?: Uint32Array
    dim?: number

    // TexturedMesh-specific fields
    texture_coords: Float32Array
    normals: Float32Array | null
    material_name: string
    tags: string[]

    // Nested dict with arrays
    material_data: Record<string, Record<string, Float32Array>>

    // Simple dict
    material_colors: Record<string, string>

    // Dict of objects with arrays (MaterialProperties)
    materials: Record<string, {
        name: string
        diffuse: Float32Array
        specular: Float32Array
        shininess: number
    }>

    // Nested Packable (PhysicsProperties)
    physics: {
        mass: number
        friction: number
        inertia_tensor: Float32Array
        collision_points: Float32Array
    } | null
}

describe('Python Integration Tests', () => {
    let zipData: Uint8Array
    const fixturePath = path.join(__dirname, 'fixtures', 'textured_mesh.zip')

    beforeAll(() => {
        // Load the fixture generated by Python
        if (!fs.existsSync(fixturePath)) {
            throw new Error(
                `Fixture not found: ${fixturePath}\n` +
                `Run: cd src/__tests__/fixtures && python generate_textured_mesh.py`
            )
        }
        zipData = new Uint8Array(fs.readFileSync(fixturePath))
    })

    describe('Mesh.decode with Python-generated TexturedMesh', () => {
        it('should decode basic mesh data (vertices, indices)', async () => {
            const mesh = await Mesh.decode(zipData)

            // Verify vertices
            expect(mesh.vertices).toBeInstanceOf(Float32Array)
            expect(mesh.vertices.length).toBe(24) // 8 vertices * 3 components

            // Verify indices  
            expect(mesh.indices).toBeInstanceOf(Uint32Array)
            expect(mesh.indices!.length).toBe(36) // 12 triangles * 3 indices

            // Verify index sizes (should be all 3s for triangles)
            expect(mesh.indexSizes).toBeInstanceOf(Uint32Array)
            expect(mesh.indexSizes!.length).toBe(12) // 12 polygons
            expect(Array.from(mesh.indexSizes!).every(s => s === 3)).toBe(true)

            // Verify cell types (5 = VTK_TRIANGLE)
            expect(mesh.cellTypes).toBeInstanceOf(Uint32Array)
            expect(mesh.cellTypes!.length).toBe(12)
            expect(Array.from(mesh.cellTypes!).every(t => t === 5)).toBe(true)

            // Verify dimension
            expect(mesh.dim).toBe(2)
        })

        it('should decode additional typed arrays (texture_coords, normals)', async () => {
            const mesh = await Mesh.decode(zipData) as unknown as TexturedMeshData

            // Texture coordinates
            expect(mesh.texture_coords).toBeInstanceOf(Float32Array)
            expect(mesh.texture_coords.length).toBe(16) // 8 vertices * 2 components

            // Normals
            expect(mesh.normals).toBeInstanceOf(Float32Array)
            expect(mesh.normals!.length).toBe(24) // 8 vertices * 3 components
        })

        it('should decode simple string fields', async () => {
            const mesh = await Mesh.decode(zipData) as unknown as TexturedMeshData

            expect(mesh.material_name).toBe('cube_material')
            expect(mesh.tags).toEqual(['cube', 'example', 'test'])
        })

        it('should decode material_colors dict (string values)', async () => {
            const mesh = await Mesh.decode(zipData) as unknown as TexturedMeshData

            expect(mesh.material_colors).toEqual({
                'cube_material': '#FF7F50',
                'secondary': '#00FF00'
            })
        })

        it('should decode material_data nested dict with arrays', async () => {
            const mesh = await Mesh.decode(zipData) as unknown as TexturedMeshData

            expect(mesh.material_data).toBeDefined()
            expect(mesh.material_data['cube_material']).toBeDefined()

            const cubeMaterial = mesh.material_data['cube_material']

            // Diffuse color (use toBeCloseTo for float32 precision)
            expect(cubeMaterial.diffuse).toBeInstanceOf(Float32Array)
            expect(cubeMaterial.diffuse[0]).toBeCloseTo(1.0, 4)
            expect(cubeMaterial.diffuse[1]).toBeCloseTo(0.5, 4)
            expect(cubeMaterial.diffuse[2]).toBeCloseTo(0.31, 4)

            // Specular color
            expect(cubeMaterial.specular).toBeInstanceOf(Float32Array)
            expect(Array.from(cubeMaterial.specular)).toEqual([0.5, 0.5, 0.5])

            // Shininess (stored as array)
            expect(cubeMaterial.shininess).toBeInstanceOf(Float32Array)
            expect(Array.from(cubeMaterial.shininess)).toEqual([32.0])
        })

        it('should decode materials dict (objects with arrays)', async () => {
            const mesh = await Mesh.decode(zipData) as unknown as TexturedMeshData

            expect(mesh.materials).toBeDefined()
            expect(Object.keys(mesh.materials)).toContain('cube_material')
            expect(Object.keys(mesh.materials)).toContain('secondary_material')

            // Check cube_material (use toBeCloseTo for float32 precision)
            const cubeMat = mesh.materials['cube_material']
            expect(cubeMat.name).toBe('cube_material')
            expect(cubeMat.shininess).toBe(32.0)
            expect(cubeMat.diffuse).toBeInstanceOf(Float32Array)
            expect(cubeMat.diffuse[0]).toBeCloseTo(1.0, 4)
            expect(cubeMat.diffuse[1]).toBeCloseTo(0.5, 4)
            expect(cubeMat.diffuse[2]).toBeCloseTo(0.31, 4)
            expect(cubeMat.specular).toBeInstanceOf(Float32Array)
            expect(Array.from(cubeMat.specular)).toEqual([0.5, 0.5, 0.5])

            // Check secondary_material
            const secondaryMat = mesh.materials['secondary_material']
            expect(secondaryMat.name).toBe('secondary_material')
            expect(secondaryMat.shininess).toBe(16.0)
            expect(secondaryMat.diffuse).toBeInstanceOf(Float32Array)
            expect(secondaryMat.diffuse[0]).toBeCloseTo(0.2, 4)
            expect(secondaryMat.diffuse[1]).toBeCloseTo(0.8, 4)
            expect(secondaryMat.diffuse[2]).toBeCloseTo(0.2, 4)
        })

        it('should decode nested Packable (physics)', async () => {
            const mesh = await Mesh.decode(zipData) as unknown as TexturedMeshData

            expect(mesh.physics).toBeDefined()
            expect(mesh.physics!.mass).toBe(2.5)
            expect(mesh.physics!.friction).toBe(0.7)

            // Inertia tensor (3x3 = 9 elements)
            expect(mesh.physics!.inertia_tensor).toBeInstanceOf(Float32Array)
            expect(mesh.physics!.inertia_tensor.length).toBe(9)

            // Collision points (3 points * 3 components = 9 elements)
            expect(mesh.physics!.collision_points).toBeInstanceOf(Float32Array)
            expect(mesh.physics!.collision_points.length).toBe(9)
        })

        it('should have correct vertex values', async () => {
            const mesh = await Mesh.decode(zipData)

            // First vertex should be at (-0.5, -0.5, -0.5)
            expect(mesh.vertices[0]).toBeCloseTo(-0.5)
            expect(mesh.vertices[1]).toBeCloseTo(-0.5)
            expect(mesh.vertices[2]).toBeCloseTo(-0.5)

            // Second vertex should be at (0.5, -0.5, -0.5)
            expect(mesh.vertices[3]).toBeCloseTo(0.5)
            expect(mesh.vertices[4]).toBeCloseTo(-0.5)
            expect(mesh.vertices[5]).toBeCloseTo(-0.5)
        })
    })

    describe('Packable.decode with Python-generated data', () => {
        it('should decode using base Packable class', async () => {
            const packable = await Packable.decode(zipData) as unknown as TexturedMeshData

            // Should have basic fields
            expect(packable.vertices).toBeInstanceOf(Float32Array)
            expect(packable.indices).toBeInstanceOf(Uint32Array)
        })
    })

    describe('Mesh utility methods on decoded mesh', () => {
        it('should report correct polygon count', async () => {
            const mesh = await Mesh.decode(zipData)
            expect(mesh.getPolygonCount()).toBe(12) // 6 faces * 2 triangles
        })

        it('should report uniform polygons (all triangles)', async () => {
            const mesh = await Mesh.decode(zipData)
            expect(mesh.isUniformPolygons()).toBe(true)
        })

        it('should convert to BufferGeometry', async () => {
            const mesh = await Mesh.decode(zipData)
            const geometry = mesh.toBufferGeometry()

            expect(geometry.attributes.position).toBeDefined()
            expect(geometry.attributes.position.count).toBe(8)
            expect(geometry.index).toBeDefined()
            expect(geometry.index!.count).toBe(36)
        })
    })
})
